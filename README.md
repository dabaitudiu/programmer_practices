# programmer_practices
algorithm practices

### 最优解Book：
1. 双栈实现getMin Stack. [Link](https://github.com/dabaitudiu/programmer_practices/blob/master/Optimal_Book/01_MinStack/description.md)
2. 双栈实现Queue. [Link](https://github.com/dabaitudiu/programmer_practices/blob/master/Optimal_Book/02_TwoStacksQueue/description.md)
3. 递归和栈实现逆序操作一个栈. [Link](https://github.com/dabaitudiu/programmer_practices/blob/master/Optimal_Book/03_Recur_Reverse_Stack/description.md)
4. 仅用一个栈排序另一个栈. [Link](https://github.com/dabaitudiu/programmer_practices/blob/master/Optimal_Book/04_SortStackByStack/description.md)
5. 打印两个有序链表的公共部分. [Link](https://github.com/dabaitudiu/programmer_practices/blob/master/Optimal_Book/05_LLCommonParts/description.md)
6. 删除单双链表倒数第K个Node. [Link](https://github.com/dabaitudiu/programmer_practices/blob/master/Optimal_Book/06_Delete_Last_Kth/description.md)
7. 换钱的方法数. [Link](https://github.com/dabaitudiu/programmer_practices/blob/master/Optimal_Book/换钱的方法数(DP).md)

### HDU-DP：
1. [牛生牛](https://github.com/dabaitudiu/programmer_practices/blob/master/DP/HDU_2018_%E7%89%9B%E7%94%9F%E7%89%9B%E9%97%AE%E9%A2%98.c)
2. [蜜蜂寻路](https://github.com/dabaitudiu/programmer_practices/blob/master/DP/HDU_2044_%E5%B0%8F%E8%9C%9C%E8%9C%82%E5%AF%BB%E8%B7%AF.c)
3. [数塔](https://github.com/dabaitudiu/programmer_practices/blob/master/DP/HDU_2084_%E6%95%B0%E5%A1%94.c%E8%B7%AF.c)

### jzOffer:
1. [二维数组中的查找](https://github.com/dabaitudiu/programmer_practices/blob/master/jzOffer/1_二维数组中的查找.md)

### 2018_xz
1. [最大乘积](https://github.com/dabaitudiu/programmer_practices/blob/master/2018_xz/1_最大乘积.md)
2. [大整数相乘](https://github.com/dabaitudiu/programmer_practices/blob/master/2018_xz/2_大整数相乘.md)
3. [分巧克力](https://github.com/dabaitudiu/programmer_practices/blob/master/2018_xz/3_分巧克力.md)
4. [彩色砖块](https://github.com/dabaitudiu/programmer_practices/blob/master/2018_xz/4_彩色砖块.md)
5. [交错01串](https://github.com/dabaitudiu/programmer_practices/blob/master/2018_xz/5_交错01串.md)
6. [操作序列](https://github.com/dabaitudiu/programmer_practices/blob/master/2018_xz/6_操作序列.md)
7. [水果与房子](https://github.com/dabaitudiu/programmer_practices/blob/master/2018_xz/7_水果与房子.md)
8. [堆棋子](https://github.com/dabaitudiu/programmer_practices/blob/master/2018_xz/8_堆棋子.md)
9. [疯狂队列](https://github.com/dabaitudiu/programmer_practices/blob/master/2018_xz/9_疯狂队列.md)
10. [循环数比较](https://github.com/dabaitudiu/programmer_practices/blob/master/2018_xz/10_循环数比较.md)
11. [DNA序列](https://github.com/dabaitudiu/programmer_practices/blob/master/2018_xz/11_DNA序列.md)
12. [猜判断题](https://github.com/dabaitudiu/programmer_practices/blob/master/2018_xz/12_猜判断题.md)
13. [删除重复字符](https://github.com/dabaitudiu/programmer_practices/blob/master/2018_xz/13_删除重复字符.md)
14. [回文素数](https://github.com/dabaitudiu/programmer_practices/blob/master/2018_xz/14_回文素数.md)
15. [字符串价值](https://github.com/dabaitudiu/programmer_practices/blob/master/2018_xz/15_字符串价值.md)
16. [拼凑正方形](https://github.com/dabaitudiu/programmer_practices/blob/master/2018_xz/16_拼凑正方形.md)
17. [区间表达](https://github.com/dabaitudiu/programmer_practices/blob/master/2018_xz/17_区间表达.md)

### LeetCode
1. [Two_Sum](https://github.com/dabaitudiu/programmer_practices/blob/master/LeetCode/1_Two_Sum.java)
2. [2_Add_Two_Numbers](https://github.com/dabaitudiu/programmer_practices/blob/master/LeetCode/2_Add_Two_Numbers.java)
3. [3_Longest_SubString](https://github.com/dabaitudiu/programmer_practices/blob/master/LeetCode/3_Longest_SubString.java)
4. [4_Median_Two_Array](https://github.com/dabaitudiu/programmer_practices/blob/master/LeetCode/4_Median_Two_Array.java)
5. [5_ZigZag_Conversion](https://github.com/dabaitudiu/programmer_practices/blob/master/LeetCode/5_ZigZag_Conversion.java)
6. [7_Inverse_Integer](https://github.com/dabaitudiu/programmer_practices/blob/master/LeetCode/7_Inverse_Integer.java)
7. [8_String_to_Integer](https://github.com/dabaitudiu/programmer_practices/blob/master/LeetCode/8_String_to_Integer.java)
8. [10_Water_container](https://github.com/dabaitudiu/programmer_practices/blob/master/LeetCode/10_Water_container.md)
9. [101_Symmetric_Tree](https://github.com/dabaitudiu/programmer_practices/blob/master/LeetCode/101_Symmetric_Tree.md)
12. [12_Integer_to_Roman](https://github.com/dabaitudiu/programmer_practices/blob/master/LeetCode/12_IntegerToRoman.md)
13. [Roman_To_Integer](https://github.com/dabaitudiu/programmer_practices/blob/master/LeetCode/13_RomanToInteger.md)
14. [Longest_Common_Prefix](https://github.com/dabaitudiu/programmer_practices/blob/master/LeetCode/14_最长前序.md)

**2019/5/7:**
```
18. 4Sum
19. Remove Nth Node From End of List
20. Valid Parentheses
21. Merge Two Sorted Lists
22. Generate Parentheses
```
- 18 3 sum 扩展版， 外层多套一个循环即可。注意判断重复及细节优化
- 19 细节：nodelist前插入一个dummy node. 删除倒数第n 等于正数查到len - n
- 20 用stack 最后stack应该是空的
- 21 遍历直到二list之一为空 
- 22 递归解决 每次传递四个变量：list, string, rightNeed, leftRest

**2019/5/8:**
```
23. Merge k Sorted Lists
24. Swap Nodes in Pairs
```
- 23 归并法实现21题O(NlogN)
- 24 链表相邻交换，while循环iterate

**2019/5/9:**
```
25. Reverse Nodes in k-Group
26. Remove Duplicates from Sorted Array
27. Remove Element    		
28. Implement strStr()    		
29. Divide Two Integers    
```

- 25 这题逆转k有个典型method，之后不断iterate
- 26 不断抓取新元素到当前index即可，之后index++
- 27 和上题一个思路
- 28 【重看】答案写法很巧妙，要点是不写循环条件 内层循环是index==needle时return 结果
- 29 【重看】 用shift operator，之后shift 除法专门有个trick 正负号用long和abs处理


**2019/5/10:**
```
30. [HARD] Substring with Concatenation of All Words
```
- 30 【重看！！！】这题做了一天，最后也只是20%左右，github答案90%多

**2019/5/11:**
```
31. Next Permutation

1.先找出最大的索引 k 满足 nums[k] < nums[k+1]，如果不存在，就翻转整个数组；
2. 再找出另一个最大索引 l 满足 nums[l] > nums[k]；
3. 交换 nums[l] 和 nums[k]；
4. 最后翻转 nums[k+1:]。
```
- 31 这题维基百科有固定公式。中文版参考: [LeetCode_31](https://leetcode-cn.com/problems/next-permutation/solution/xia-yi-ge-pai-lie-by-powcai/)

**2019/5/12:**
```
32. Longest Valid Parentheses
33. Search in Rotated Sorted Array
34. Find First and Last Position of Element in Sorted Array
```
- 32 这题两个方法 第一个:用stack 找出所有配对括号的index，之后找出最长的连续index串，这里有个trick可以省去排序使最后为O(N). 第二个方法: dp，dp[i]代表该位置作为结尾最长valid括号是多少，'(' 的dp 全为0， 之后分dp[i-1] = '(' 和 dp[i=1] = ')' 讨论。详情见这里: [32. 最长有效括号](https://leetcode-cn.com/problems/longest-valid-parentheses/solution/zui-chang-you-xiao-gua-hao-by-powcai/)
- 33 先用二分法找分割点，之后用常规二分法查找，只不过real_mid = (mid + shift) % len.
- 34 2个思路 1. 普通二分法，之后向左右延展，速度一般。 2. 二分法找左右分界，<=(或>=)都要继续移动边界，但=target时要记录index. 最后返回的index即为边界. (最快最省空间)

**2019/5/13:**
```
35. Search Insert Position
36. Valid Sudoku
37. Sudoku Solver
```
- 35 终于一次AC就过了。就是简单的二分查找，判断好停止位置. 小于target就在后方insert, 大于就在当前index insert.
- 36 这题答案巧。只用一个set就可以搞定，key定义成string: "5 in row 0" 形式就行了，省时间省空间. box序号用i,j算出来
- 37 这题的答案太强了。。链接: [LeetCode37](https://www.youtube.com/watch?v=ucugbKwjtRs). 思路是先扫面一遍，靠rows,cols,boxs，三个约束进行枚举,用递归来完成。真实体现递归之美，答案太强了。。

**2019/5/15:**
```
38. Count and Say
39. Combination Sum
40. Combination Sum II
41. First Missing Positive
42. Trapping Rain Water
```
- 38 无脑递归题
- 39 【重做】凑钱问题。回溯法，递归。这个题自己递归没想出来，看了答案也没完全理解好，最后还是相当于背下来的，必须重做。
- 40 【重做】遗憾。上一题几乎都是背完了这题还是没做出来，跟上一个题几乎一模一样，只要每次index往后移动一位就行了。唯一注意的就是去重和及时break。啥都不说了。菜是原罪
- 41 这题的思想是遍历一遍nums, 把nums[i]放在i位置上，再遍历一遍nums，若i != nums[i] - 1, 说明这个数缺失。不过这个条件不完全，如果nums中有重复的数字那么就会无限循环, nums[i] != nums[nums[i - 1]] 可以忽略重复元素的情况。
- 42 和之前做过的蓄水池题类似。每个column积累的雨水量等于左右两边较小的max_barrier_height减去当前height. 3个方法：1. dp 求出每个column's left_max & right_max; 2. stack【还没看这个】 3. 左右两个pointer,每次移动交低height的一端，不断update max_left/right height,并积累面积值。

**2019/5/16:**
```
43. Multiply Strings
44. Wildcard Matching
```
- 43 校招做过的一道题 然而还是没记住。反转两个字符串, i,j位置乘积累加进arr[i + j], 之后遍历arr, 留下%10, carry进位传到arr[i+1]. 最后从末尾往前加进result的string，注意去0即可。注意额外判断0*0.
- 44 经典题 通配符匹配 两个方法，一个贪心法，一个dp，还是算是背下来的，肯定要重做了。dp法，两种讨论。1. ```s[i] == p[i] || p[i] == '?' 2. p[i] == '*', dp[i][j-1] == true || dp[i-1][j-1] == true```

**2019/5/18:**
```
45. Jump Game II   
46. Permutations
47. Permutations II
48. Rotate Image
```
- 45 贪心法，每次在当前步伐范围内搜索能到达的最远的点
- 46 回溯法经典题 - 无重复元素排列
- 47 回溯法经典题 - 有重复元素排列
- 48 翻转matrix. 两个方法: (1) 对于每一圈，都进行的是4个元素间的swap (2) 先上下翻转，再按对角线翻转

**2019/5/18:**
```
49. Group Anagrams    
50. Pow(x, n)    
```
- 49,50 没啥营养的两道题

